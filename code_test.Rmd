---
title: "Benchmark code test"
author: "Sisi"
date: "7/18/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# load the package
library(tictoc)
library(DesignLibrary)


source('uihelpers.R')
source('common.R')
source('inspect_helpers.R')

# ---------------------------- functions -----------------------------------
# return args which are not vectors, num cannot be larger than 3 
args_index <- function(name, num, arg_defs){
    # find out all the vector parameters in 
    for (index in 1:length(name)){
        if (arg_defs[arg_defs$names == name[index],]$vector == T ||
            arg_defs[arg_defs$names == name[index],]$class == "logical" || 
            "outcome_name"  ==  name[index] || 
            "k" == name[index] ||
            "m_arms" == name[index] ||
            "sd_i_0" == name[index] ||
            "icc" == name[index]){
            name[index] <- NA
        }else{
            next()
        }
    }
    # remove all the NA, get the argname without vector 
    argname_novec <- name[!is.na(name)]
    # all the possible index combinations of args
    args_index <- expand.grid(rep(list(seq(1:length(argname_novec))),num))
    
    if (num > 2){
        # order the dataframe 
        args_index <- args_index[order(args_index[,1], args_index[,2]),]
        # the values in the var1 should be smaller than the values in var2
        # similarly, the values in the var2 should be larger than the value in var3
        args_index <- args_index[args_index[1] < args_index[2] & args_index[2] < args_index[3],]
    }else if (num == 2){
        # remove the combinations with same elements 
        args_index <- args_index[sapply(1:nrow(args_index), function(x){length(unique(unlist(args_index[x,]))) >1}),]
        # order the dataframe 
        args_index <- args_index[order(args_index[,1]),]
        args_index <- args_index[args_index[1] < args_index[2],]
    }else{
        args_indexy <- argname_novec
    }
    
    rownames(args_index) <- NULL
    # args_index is not equal to argname any more! 
    return(list(argname_novec,args_index))
}

# get design, arguments definition, arguments evaluation
get_designs <- function(id){
    design <- getFromNamespace(id, 'DesignLibrary')
    args_design <- get_designer_args(design)
    arg_defs <- attr(design, 'definitions') 
    args_eval <- evaluate_designer_args(args_design, attr(design, 'definitions'))
    args_eval[sapply(args_eval, is.null)] <- NULL
    argname <- names(args_eval)
    # set the right class of args 
    for(i  in (1: length(argname))){
        if (arg_defs[arg_defs$names == argname[i], ]$class != class(args_eval[[argname[i]]]) & is.character(args_eval[[argname[i]]])){
            if (arg_defs[arg_defs$names == argname[i], ]$vector == T){
                arg_value <- trimws(strsplit(args_eval[[argname[i]]], ",")[[1]])
                arg_value <- unname(sapply(arg_value, function(x) eval(parse(text=x))))
                args_eval[[argname[i]]] <- list(arg_value)
            }       
        }
    }
    
    return(list(design = design, arg_defs = arg_defs , args_eval = args_eval))
}
# function of running  the diagnoses 
run_diagnoses_test_code <- function(designer, args, sims, bootstrap_sims) {
    all_designs <- eval_bare(expr(expand_design(designer = designer, expand = TRUE, !!!args)))
    # simulate data
    simdata <- simulate_designs(all_designs, sims = sims)
    # run diagnoses using the simulated data
    diag_res <- diagnose_designs(simdata,bootstrap_sims = bootstrap_sims)
    return(diag_res)
}

# varying the first arg 
varying_arg <- function(argname, args){
    if (argname  == 'N') {
        n_int <- args[[argname]]
        args[[argname]] <- seq(n_int,  n_int + 100, 10)
    } else {
        min_int <- arg_defs[arg_defs$names == argname,]$inspector_min
        step_int <- arg_defs[arg_defs$names == argname,]$inspector_step
        max_int <- min_int + 4*step_int
        args[[argname]] <- seq(min_int,  max_int, step_int)
    }
    return(args)
}


# running time by different no. of combination arguments and id of design 
# num can be only 1, 2, 3
diagnose_varying_args <- function(num, id){
    design <- get_designs(id)[["design"]]
    arg_defs <- get_designs(id)[["arg_defs"]]
    args_eval <- get_designs(id)[["args_eval"]]
    argname <- names(args_eval)
    index <-  args_index(argname, num,  arg_defs)
    # get the agrname without vector
    agrname_novec <- index[[1]]
    # all possible combinations of arguments
    arg_index <- index[[2]]
    if (num == 1){
        first_arg <- 1
        second_arg <- NULL
        thrid_arg <- NULL
    }else if(num == 2){
        first_arg <- 1
        second_arg <- 1
        thrid_arg <- NULL
    }else{
        first_arg <- 1
        second_arg <- 1
        thrid_arg <- 1
    }


    for (i in 1:nrow(arg_index)){
        first_arg <- agrname_novec[arg_index[i,][[1]]]
        args_eval <-  varying_arg(first_arg, args_eval)

        if (!is.null(second_arg) & !is.null(thrid_arg) & !is.null(first_arg)){
            second_arg <- agrname_novec[arg_index[i,][[2]]]
            thrid_arg <- agrname_novec[arg_index[i,][[3]]]
            # vary the second args
            min_int <- arg_defs[arg_defs$names == second_arg,]$inspector_min
            step_int <- arg_defs[arg_defs$names == second_arg,]$inspector_step
            max_int <- min_int + 4*step_int
            args_eval[[second_arg]] <- seq(min_int,  max_int, step_int)
            # vary the thrid args
            min_int <- arg_defs[arg_defs$names == thrid_arg,]$inspector_min
            step_int <- arg_defs[arg_defs$names == thrid_arg,]$inspector_step
            max_int <- min_int + 4*step_int
            args_eval[[thrid_arg]] <- seq(min_int,  max_int, step_int)

            tic(paste(first_arg, second_arg, third_arg, id, sep = ","))

            diag_result <- run_diagnoses_test_code(design, args_eval, 100, 30)

            toc()
            args_eval <- get_designs(id)[["args_eval"]]
        }else if(!is.null(second_arg)){
            second_arg <- agrname_novec[arg_index[i,][[2]]]
            # vary the second args
            min_int <- arg_defs[arg_defs$names == second_arg,]$inspector_min
            step_int <- arg_defs[arg_defs$names == second_arg,]$inspector_step
            max_int <- min_int + 4*step_int
            args_eval[[second_arg]] <- seq(min_int,  max_int, step_int)

            tic(paste(first_arg, second_arg, id, sep = ","))
            diag_result <- run_diagnoses_test_code(design, args_eval, 100, 30)
            toc()
            args_eval <- get_designs(id)[["args_eval"]]
        }else{
            tic(paste(first_arg,id, sep = ","))
            diag_result <- run_diagnoses_test_code(design, args_eval, 100, 30)
            toc()
            args_eval <- get_designs(id)[["args_eval"]]
        }
    }
    
    return(diag_result)
}

```

## Running Code Time 
### Slowest simulation of design

Compare the running time of simulations of all the designs, design parameters are initialized with default values. It's easy to see that the slowest is cluster_sampling_designer, and the fastes is randomized_response_designer.

```{r default sim, echo=F, warning=FALSE}
# get all the design names 
cached <- str_replace(grep("designer$", ls(as.environment("package:DesignLibrary")), value = TRUE), "_designer", "")
option <- c()
for (i in 1:length(cached)){
    if (is.null(attr(getFromNamespace(paste(cached[i], sep = "_", "designer"), 'DesignLibrary'), "shiny"))){
        next()
    }else{
        option[i] <- paste(cached[i], sep = "_", "designer")
    }
}
option <- option[complete.cases(option)]

# find the slowest design by simulation 
for (id in option){
    tic(id)
    sim_design <- getFromNamespace(id, 'DesignLibrary')
    simulate_design(sim_design(), sims = 100)
    toc()
}

```

Binary IV design

```{r binary_iv, echo=F, warning=FALSE}
diagnose_varying_args(num = 1, id = option[1])
diagnose_varying_args(num = 2, id = option[1])
# sapply(1:2, diagnose_varying_args, id = option[1])
```

Block Cluster Two Arm design

```{r block_cluster_two_arm, echo=F, warning=FALSE}
diagnose_varying_args(num = 1, id = option[2])
# diagnose_varying_args(num = 2, id = option[2])
#sapply(1:2, diagnose_varying_args, id = option[2])
```

Cluster Sampling design, "N_blocks" is only varied.

```{r cluster_sampling, echo=F, warning=FALSE}
diagnose_varying_args(num = 1, id = option[3])
```

Factorial design

```{r echo=F, warning=FALSE}
diagnose_varying_args(num = 1, id = option[4])
# diagnose_varying_args(num =2, id = option[4])
# sapply(1:2, diagnose_varying_args, id = option[4])
```

Mediation Analysis design

```{r echo=F, warning=FALSE}
diagnose_varying_args(num = 1, id = option[4])
```

<!-- Multi Arm design -->

<!-- #```{r echo=F, warning=FALSE} -->
<!-- #sapply(1:2, diagnose_varying_args, id = option[6]) -->
<!-- #``` -->

Pretest Posttest design

```{r echo=F, warning=FALSE}
diagnose_varying_args(num = 1, id = option[7])
# sapply(1:2, diagnose_varying_args, id = option[7])
```

Process Tracing design

```{r echo=F, warning=FALSE}
# iagnose_varying_args(num = 1, id = option[8])
# sapply(1:2, diagnose_varying_args, id = option[8])
```

Randomized Response design

```{r echo=F, warning=FALSE}
diagnose_varying_args(num = 1, id = option[9])
#sapply(1:2, diagnose_varying_args, id = option[9])
```

Regression Discontinuity design

```{r echo=F, warning=FALSE}
diagnose_varying_args(num = 1, id = option[10])
# sapply(1:2, diagnose_varying_args, id = option[10])
```

Spillover design
```{r echo=F, warning=FALSE}
diagnose_varying_args(num = 1, id = option[11])
#sapply(1:2, diagnose_varying_args, id = option[11])
```

Two Arm Attrition design
```{r echo=F, warning=FALSE}
diagnose_varying_args(num = 1, id = option[12])
#sapply(1:2, diagnose_varying_args, id = option[12])
```

Two Arm Covariate design
```{r echo=F, warning=FALSE}
diagnose_varying_args(num = 1, id = option[13])
# sapply(1:2, diagnose_varying_args, id = option[13])
```

Two Arm design
```{r echo=F, warning=FALSE}
# diagnose_varying_args(num = 1, id = option[14])
#sapply(1:2, diagnose_varying_args, id = option[14])
```

Two by Two design
```{r echo=F, warning=FALSE}
#diagnose_varying_args(num = 1, id = option[15])
# sapply(1:2, diagnose_varying_args, id = option[15])
```
